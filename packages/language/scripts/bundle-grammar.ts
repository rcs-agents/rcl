import {
	appendFile,
	mkdir,
	readFile,
	rm,
	writeFile,
} from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

// Get command line arguments
const args = process.argv.slice(2);
const isTestGrammar = args.includes('--test');

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const grammarDir = path.resolve(__dirname, "..", "src", "grammar");

// Choose entry file and output file based on mode
const entryFile = isTestGrammar 
    ? path.resolve(grammarDir, "rcl-tests.langium")
    : path.resolve(grammarDir, "rcl.langium");
    
const outputFile = isTestGrammar
    ? path.resolve(grammarDir, "..", "rcl-test-grammar.langium")
    : path.resolve(grammarDir, "..", "rcl-grammar.langium");

const logDir = path.resolve(__dirname, "..", "logs");
const logFile = path.resolve(logDir, "bundle-grammar.log");

async function log(message: string): Promise<void> {
	const timestamp = new Date().toISOString();
	await appendFile(logFile, `[${timestamp}] ${message}\n`);
}

async function bundle(
	filePath: string,
	processedFiles: Set<string>,
): Promise<string> {
	const absolutePath = path.resolve(filePath);
	if (processedFiles.has(absolutePath)) {
		await log(`Skipping already processed file: ${absolutePath}`);
		return "";
	}
	await log(`Processing file: ${absolutePath}`);
	processedFiles.add(absolutePath);

	let content: string;
	try {
		content = await readFile(absolutePath, "utf-8");
	} catch (error) {
		await log(`Error reading file ${absolutePath}: ${error}`);
		throw error;
	}

	const lines = content.split(/\r?\n/);
	const output: string[] = [];

	const importRegex = /^\s*import\s+"([^"]+)";/;

	for (const line of lines) {
		if (line.trim().startsWith("//")) {
			continue;
		}

		const match = line.match(importRegex);
		if (match) {
			const importPath = match[1];
			const importedFile = path.resolve(
				path.dirname(absolutePath),
				`${importPath}.langium`,
			);
			output.push(await bundle(importedFile, processedFiles));
		} else {
			output.push(line);
		}
	}

	return output.join("\n");
}

async function main(): Promise<void> {
	try {
		const grammarType = isTestGrammar ? 'test' : 'main';
		await mkdir(logDir, { recursive: true });
		await writeFile(
			logFile,
			`--- Log for ${grammarType} grammar bundling at ${new Date().toISOString()} ---\n`,
		);

		// Delete the existing bundled file to ensure a clean build
		await rm(outputFile, { force: true });
		await log(`Removed existing bundled file: ${outputFile}`);

		await log(`Starting ${grammarType} grammar bundling process...`);
		const processedFiles = new Set<string>();
		let bundledContent = await bundle(entryFile, processedFiles);

		const grammarNameRegex = /grammar\s+([A-Za-z_][A-Za-z0-9_]*)/;
		const grammarMatch = bundledContent.match(grammarNameRegex);
		if (grammarMatch) {
			const grammarName = grammarMatch[1];
			const grammarDeclaration = `grammar ${grammarName}`;
			// Remove all grammar declarations from the bundled content
			bundledContent = bundledContent.replace(
				/grammar\s+[A-Za-z_][A-Za-z0-9_]*/g,
				"",
			);
			// Add a single grammar declaration at the top
			bundledContent = `${grammarDeclaration}\n\n${bundledContent}`;
		}

		// Ensure no more than two blank lines in a row
		bundledContent = bundledContent.replace(/(\n\s*){3,}/g, '\n\n');

		// Add warning header to the bundled file
		const warningHeader = `/*
 * ========================================================================
 * ðŸš¨ WARNING: THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT! ðŸš¨
 * ========================================================================
 * 
 * This file is generated by the bundle-grammar.ts script from the modular
 * grammar files in the src/grammar/ directory.
 * 
 * To make changes:
 * 1. Edit the source .langium files in packages/language/src/grammar/
 * 2. Run: bun run build:lang
 * 3. The script will regenerate this bundled file automatically
 * 
 * Any direct edits to this file WILL BE LOST on the next build!
 * 
 * Generated at: ${new Date().toISOString()}
 * ========================================================================
 */

`;

		bundledContent = warningHeader + bundledContent;

		await writeFile(outputFile, bundledContent);
		await log(`Successfully bundled ${grammarType} grammar to ${outputFile}`);
		console.log(`${grammarType.charAt(0).toUpperCase() + grammarType.slice(1)} grammar bundled successfully to ${outputFile}`);
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		await log(`An error occurred: ${errorMessage}`);
		console.error("An error occurred during bundling:", error);
		process.exit(1);
	}
}

main(); 