/**
 * RCL Token Definitions
 * 
 * Defines all token types for the Rich Communication Language according to the formal specification.
 * This is the central registry for all tokens used by the lexer and parser.
 */

import { createToken, Lexer } from 'chevrotain';
import type { TokenType } from 'chevrotain';

/**
 * All RCL tokens organized by category for better maintainability
 */
export class RclTokens {
  // ============================================
  // SYNTHETIC TOKENS (Generated by lexer logic)
  // ============================================
  
  /** Synthetic token for increased indentation */
  static readonly INDENT = createToken({ 
    name: 'INDENT', 
    pattern: Lexer.NA 
  });
  
  /** Synthetic token for decreased indentation */
  static readonly DEDENT = createToken({ 
    name: 'DEDENT', 
    pattern: Lexer.NA 
  });

  // ============================================
  // WHITESPACE AND COMMENTS
  // ============================================
  
  /** Horizontal whitespace (spaces and tabs) */
  static readonly WS = createToken({ 
    name: 'WS', 
    pattern: /[ \t]+/, 
    group: 'whitespace' 
  });
  
  /** Newline characters */
  static readonly NL = createToken({ 
    name: 'NL', 
    pattern: /\r?\n/, 
    group: 'whitespace' 
  });
  
  /** Single-line comments starting with # */
  static readonly SL_COMMENT = createToken({ 
    name: 'SL_COMMENT', 
    pattern: /#[^\r\n]*/ 
  });

  // ============================================
  // IMPORT KEYWORDS
  // ============================================
  
  static readonly IMPORT_KW = createToken({ name: 'import', pattern: /import\b/ });
  static readonly AS_KW = createToken({ name: 'as', pattern: /as\b/ });
  static readonly FROM_KW = createToken({ name: 'from', pattern: /from\b/ });

  // ============================================
  // SECTION KEYWORDS
  // ============================================
  
  static readonly AGENT_KW = createToken({ name: 'agent', pattern: /agent\b/ });
  static readonly AGENT_DEFAULTS_KW = createToken({ name: 'agentDefaults', pattern: /agentDefaults\b/ });
  static readonly AGENT_CONFIG_KW = createToken({ name: 'agentConfig', pattern: /agentConfig\b/ });
  static readonly FLOW_KW = createToken({ name: 'flow', pattern: /flow\b/ });
  static readonly FLOWS_KW = createToken({ name: 'flows', pattern: /flows\b/ });
  static readonly MESSAGES_KW = createToken({ name: 'messages', pattern: /messages\b/ });

  // ============================================
  // MESSAGE KEYWORDS
  // ============================================
  
  static readonly AGENT_MESSAGE_KW = createToken({ name: 'agentMessage', pattern: /agentMessage\b/ });
  static readonly CONTENT_MESSAGE_KW = createToken({ name: 'contentMessage', pattern: /contentMessage\b/ });
  static readonly SUGGESTION_KW = createToken({ name: 'suggestion', pattern: /suggestion\b/ });

  // ============================================
  // MESSAGE SHORTCUT KEYWORDS
  // ============================================
  
  static readonly TEXT_KW = createToken({ name: 'text', pattern: /text\b/ });
  static readonly RICH_CARD_KW = createToken({ name: 'richCard', pattern: /richCard\b/ });
  static readonly CAROUSEL_KW = createToken({ name: 'carousel', pattern: /carousel\b/ });
  static readonly RBM_FILE_KW = createToken({ name: 'rbmFile', pattern: /rbmFile\b/ });
  static readonly FILE_KW = createToken({ name: 'file', pattern: /file\b/ });

  // ============================================
  // ACTION KEYWORDS
  // ============================================
  
  static readonly REPLY_KW = createToken({ name: 'reply', pattern: /reply\b/ });
  static readonly ACTION_KW = createToken({ name: 'action', pattern: /action\b/ });
  static readonly DIAL_KW = createToken({ name: 'dial', pattern: /dial\b/ });
  static readonly DIAL_ACTION_KW = createToken({ name: 'dialAction', pattern: /dialAction\b/ });
  static readonly OPEN_URL_KW = createToken({ name: 'openUrl', pattern: /openUrl\b/ });
  static readonly OPEN_URL_ACTION_KW = createToken({ name: 'openUrlAction', pattern: /openUrlAction\b/ });
  static readonly SHARE_LOCATION_KW = createToken({ name: 'shareLocation', pattern: /shareLocation\b/ });
  static readonly SHARE_LOCATION_ACTION_KW = createToken({ name: 'shareLocationAction', pattern: /shareLocationAction\b/ });
  static readonly VIEW_LOCATION_KW = createToken({ name: 'viewLocation', pattern: /viewLocation\b/ });
  static readonly VIEW_LOCATION_ACTION_KW = createToken({ name: 'viewLocationAction', pattern: /viewLocationAction\b/ });
  static readonly SAVE_EVENT_KW = createToken({ name: 'saveEvent', pattern: /saveEvent\b/ });
  static readonly CREATE_CALENDAR_EVENT_ACTION_KW = createToken({ name: 'createCalendarEventAction', pattern: /createCalendarEventAction\b/ });
  static readonly COMPOSE_ACTION_KW = createToken({ name: 'composeAction', pattern: /composeAction\b/ });

  // ============================================
  // FLOW CONTROL KEYWORDS
  // ============================================
  
  static readonly START_KW = createToken({ name: 'start', pattern: /start\b/ });
  static readonly WITH_KW = createToken({ name: 'with', pattern: /with\b/ });
  static readonly WHEN_KW = createToken({ name: 'when', pattern: /when\b/ });
  static readonly IF_KW = createToken({ name: 'if', pattern: /if\b/ });
  static readonly THEN_KW = createToken({ name: 'then', pattern: /then\b/ });
  static readonly ELSE_KW = createToken({ name: 'else', pattern: /else\b/ });
  static readonly UNLESS_KW = createToken({ name: 'unless', pattern: /unless\b/ });
  static readonly AND_KW = createToken({ name: 'and', pattern: /and\b/ });
  static readonly OR_KW = createToken({ name: 'or', pattern: /or\b/ });
  static readonly NOT_KW = createToken({ name: 'not', pattern: /not\b/ });
  static readonly IS_KW = createToken({ name: 'is', pattern: /is\b/ });
  static readonly DO_KW = createToken({ name: 'do', pattern: /do\b/ });
  static readonly END_KW = createToken({ name: 'end', pattern: /end\b/ });

  // ============================================
  // COLLECTION KEYWORDS
  // ============================================
  
  static readonly LIST_KW = createToken({ name: 'list', pattern: /list\b/ });
  static readonly OF_KW = createToken({ name: 'of', pattern: /of\b/ });

  // ============================================
  // MESSAGE TRAFFIC TYPE KEYWORDS
  // ============================================
  
  static readonly TRANSACTIONAL_KW = createToken({ name: 'transactional', pattern: /transactional\b/ });
  static readonly PROMOTIONAL_KW = createToken({ name: 'promotional', pattern: /promotional\b/ });

  // ============================================
  // BOOLEAN LITERALS
  // ============================================
  
  static readonly TRUE_KW = createToken({ name: 'True', pattern: /True\b/ });
  static readonly YES_KW = createToken({ name: 'Yes', pattern: /Yes\b/ });
  static readonly ON_KW = createToken({ name: 'On', pattern: /On\b/ });
  static readonly ENABLED_KW = createToken({ name: 'Enabled', pattern: /Enabled\b/ });
  static readonly ACTIVE_KW = createToken({ name: 'Active', pattern: /Active\b/ });
  static readonly FALSE_KW = createToken({ name: 'False', pattern: /False\b/ });
  static readonly NO_KW = createToken({ name: 'No', pattern: /No\b/ });
  static readonly OFF_KW = createToken({ name: 'Off', pattern: /Off\b/ });
  static readonly DISABLED_KW = createToken({ name: 'Disabled', pattern: /Disabled\b/ });
  static readonly INACTIVE_KW = createToken({ name: 'Inactive', pattern: /Inactive\b/ });

  // ============================================
  // NULL LITERALS
  // ============================================
  
  static readonly NULL_KW = createToken({ name: 'Null', pattern: /Null\b/ });
  static readonly NULL_LOWERCASE_KW = createToken({ name: 'null', pattern: /null\b/ });
  static readonly NONE_KW = createToken({ name: 'None', pattern: /None\b/ });
  static readonly VOID_KW = createToken({ name: 'Void', pattern: /Void\b/ });

  // ============================================
  // RESERVED NAMES
  // ============================================
  
  static readonly DEFAULTS_KW = createToken({ name: 'Defaults', pattern: /Defaults\b/ });
  static readonly CONFIG_KW = createToken({ name: 'Config', pattern: /Config\b/ });
  static readonly MESSAGES_RESERVED_KW = createToken({ name: 'Messages', pattern: /Messages\b/ });

  // ============================================
  // TYPE TAG NAMES
  // ============================================
  
  static readonly EMAIL_TYPE = createToken({ name: 'email', pattern: /email\b/ });
  static readonly PHONE_TYPE = createToken({ name: 'phone', pattern: /phone\b/ });
  static readonly MSISDN_TYPE = createToken({ name: 'msisdn', pattern: /msisdn\b/ });
  static readonly URL_TYPE = createToken({ name: 'url', pattern: /url\b/ });
  static readonly TIME_TYPE = createToken({ name: 'time', pattern: /time\b/ });
  static readonly T_TYPE = createToken({ name: 't', pattern: /t\b/ });
  static readonly DATETIME_TYPE = createToken({ name: 'datetime', pattern: /datetime\b/ });
  static readonly DATE_TYPE = createToken({ name: 'date', pattern: /date\b/ });
  static readonly DT_TYPE = createToken({ name: 'dt', pattern: /dt\b/ });
  static readonly ZIPCODE_TYPE = createToken({ name: 'zipcode', pattern: /zipcode\b/ });
  static readonly ZIP_TYPE = createToken({ name: 'zip', pattern: /zip\b/ });
  static readonly DURATION_TYPE = createToken({ name: 'duration', pattern: /duration\b/ });
  static readonly TTL_TYPE = createToken({ name: 'ttl', pattern: /ttl\b/ });

  // ============================================
  // IDENTIFIERS (Fixed pattern per specification)
  // ============================================
  
  /** 
   * Identifiers must start with uppercase letter per formal specification
   * Fixed: Removed word boundary to support space-separated identifiers 
   */
  static readonly IDENTIFIER = createToken({ 
    name: 'IDENTIFIER', 
    pattern: /[A-Z]([A-Za-z0-9-_]|(\s(?=[A-Z0-9])))*/, // Removed \b per spec
    line_breaks: false
  });
  
  static readonly ATTRIBUTE_KEY = createToken({ 
    name: 'ATTRIBUTE_KEY', 
    pattern: /[a-z][a-zA-Z0-9_]*(?=\s*:)/
  });
  
  static readonly SECTION_TYPE = createToken({ 
    name: 'SECTION_TYPE', 
    pattern: /[a-z][a-zA-Z0-9_]*\b/
  });

  // ============================================
  // LITERALS
  // ============================================
  
  static readonly ISO_DURATION_LITERAL = createToken({
    name: 'ISO_DURATION_LITERAL',
    pattern: /(P((\d+Y)|(\d+M)|(\d+W)|(\d+D)|(T((\d+H)|(\d+M)|(\d+(\.\d+)?S))+))+)|([0-9]+(\.[0-9]+)?s)/,
    line_breaks: false
  });
  
  static readonly STRING = createToken({ 
    name: 'STRING', 
    pattern: /"(\\.|[^"\\])*"/
  });
  
  static readonly NUMBER = createToken({ 
    name: 'NUMBER', 
    pattern: /[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?/
  });
  
  static readonly ATOM = createToken({ 
    name: 'ATOM', 
    pattern: /:([_a-zA-Z][\w_]*|"[^"\\]*")/
  });

  // ============================================
  // EMBEDDED EXPRESSIONS (Fixed per specification)
  // ============================================
  
  /**
   * Multi-line expression start marker
   * Fixed: Removed braces pattern to match specification (indentation-based)
   */
  static readonly MULTI_LINE_EXPRESSION_START = createToken({
    name: 'MULTI_LINE_EXPRESSION_START',
    pattern: /\$((js|ts)?)>>>/ // Fixed: removed brace pattern
  });
  
  /**
   * Single-line embedded expressions
   * Fixed: Corrected pattern to match specification exactly
   */
  static readonly EMBEDDED_CODE = createToken({
    name: 'EMBEDDED_CODE',
    pattern: /\$((js|ts)?>)\s*[^\r\n]*/ // Pattern: $js> code, $ts> code, $> code
  });

  // ============================================
  // MULTI-LINE STRING MARKERS (Chomping markers)
  // ============================================
  
  static readonly MULTILINE_STR_PRESERVE_ALL = createToken({
    name: 'MULTILINE_STR_PRESERVE_ALL',
    pattern: /\+\|\+(?=\s*(?:\r?\n|$))/
  });
  
  static readonly MULTILINE_STR_PRESERVE = createToken({
    name: 'MULTILINE_STR_PRESERVE',
    pattern: /\+\|(?=\s*(?:\r?\n|$))/
  });
  
  static readonly MULTILINE_STR_TRIM = createToken({
    name: 'MULTILINE_STR_TRIM',
    pattern: /\|-(?=\s*(?:\r?\n|$))/
  });
  
  static readonly MULTILINE_STR_CLEAN = createToken({
    name: 'MULTILINE_STR_CLEAN',
    pattern: /\|(?=\s*(?:\r?\n|$))/
  });

  // ============================================
  // SYNTHETIC CONTENT TOKENS
  // ============================================
  
  /** Content extracted from multi-line strings */
  static readonly STRING_CONTENT = createToken({
    name: 'STRING_CONTENT',
    pattern: Lexer.NA
  });
  
  /** Content extracted from multi-line expressions */
  static readonly MULTI_LINE_EXPRESSION_CONTENT = createToken({
    name: 'MULTI_LINE_EXPRESSION_CONTENT',
    pattern: Lexer.NA
  });

  // ============================================
  // TYPE TAG CONTENT TOKENS
  // ============================================
  
  static readonly TYPE_TAG_VALUE_CONTENT = createToken({
    name: 'TYPE_TAG_VALUE_CONTENT',
    pattern: Lexer.NA
  });
  
  static readonly TYPE_TAG_MODIFIER_CONTENT = createToken({
    name: 'TYPE_TAG_MODIFIER_CONTENT',
    pattern: Lexer.NA
  });

  // ============================================
  // PUNCTUATION AND OPERATORS
  // ============================================
  
  static readonly ARROW = createToken({ name: 'ARROW', pattern: /->/ });
  static readonly APOSTROPHE_S = createToken({ name: 'APOSTROPHE_S', pattern: /'s/ });
  static readonly PIPE = createToken({ name: 'PIPE', pattern: /\|/ });
  static readonly COLON = createToken({ name: 'COLON', pattern: /:/ });
  static readonly COMMA = createToken({ name: 'COMMA', pattern: /,/ });
  static readonly DOT = createToken({ name: 'DOT', pattern: /\./ });
  static readonly SLASH = createToken({ name: 'SLASH', pattern: /\// });
  static readonly HYPHEN = createToken({ name: 'HYPHEN', pattern: /-/ });
  static readonly DOLLAR = createToken({ name: 'DOLLAR', pattern: /\$/ });
  static readonly PERCENT = createToken({ name: 'PERCENT', pattern: /%/ });
  static readonly AT = createToken({ name: 'AT', pattern: /@/ });
  static readonly CARET = createToken({ name: 'CARET', pattern: /\^/ });

  // ============================================
  // BRACKETS AND BRACES
  // ============================================
  
  static readonly LPAREN = createToken({ name: 'LPAREN', pattern: /\(/ });
  static readonly RPAREN = createToken({ name: 'RPAREN', pattern: /\)/ });
  static readonly LBRACE = createToken({ name: 'LBRACE', pattern: /\{/ });
  static readonly RBRACE = createToken({ name: 'RBRACE', pattern: /\}/ });
  static readonly LBRACKET = createToken({ name: 'LBRACKET', pattern: /\[/ });
  static readonly RBRACKET = createToken({ name: 'RBRACKET', pattern: /\]/ });
  static readonly LT = createToken({ name: 'LT', pattern: /</ });
  static readonly GT = createToken({ name: 'GT', pattern: />/ });

  // ============================================
  // TOKEN ORDERING (Most specific first)
  // ============================================
  
  /**
   * All tokens in priority order for lexer processing
   * Order matters: more specific patterns must come before general ones
   */
  static readonly ALL_TOKENS: TokenType[] = [
    // Synthetic tokens
    RclTokens.INDENT,
    RclTokens.DEDENT,
    
    // Whitespace and comments
    RclTokens.WS,
    RclTokens.NL,
    RclTokens.SL_COMMENT,

    // Import keywords
    RclTokens.IMPORT_KW,
    RclTokens.AS_KW,
    RclTokens.FROM_KW,

    // Section keywords (longer patterns first)
    RclTokens.AGENT_DEFAULTS_KW,
    RclTokens.AGENT_CONFIG_KW,
    RclTokens.AGENT_KW,
    RclTokens.FLOWS_KW,
    RclTokens.FLOW_KW,
    RclTokens.MESSAGES_KW,

    // Message keywords
    RclTokens.AGENT_MESSAGE_KW,
    RclTokens.CONTENT_MESSAGE_KW,
    RclTokens.SUGGESTION_KW,

    // Message shortcut keywords
    RclTokens.RICH_CARD_KW,
    RclTokens.CAROUSEL_KW,
    RclTokens.RBM_FILE_KW,
    RclTokens.TEXT_KW,
    RclTokens.FILE_KW,

    // Action keywords (longer patterns first)
    RclTokens.CREATE_CALENDAR_EVENT_ACTION_KW,
    RclTokens.SHARE_LOCATION_ACTION_KW,
    RclTokens.VIEW_LOCATION_ACTION_KW,
    RclTokens.OPEN_URL_ACTION_KW,
    RclTokens.DIAL_ACTION_KW,
    RclTokens.COMPOSE_ACTION_KW,
    RclTokens.SHARE_LOCATION_KW,
    RclTokens.VIEW_LOCATION_KW,
    RclTokens.SAVE_EVENT_KW,
    RclTokens.OPEN_URL_KW,
    RclTokens.ACTION_KW,
    RclTokens.REPLY_KW,
    RclTokens.DIAL_KW,

    // Flow control keywords
    RclTokens.START_KW,
    RclTokens.WITH_KW,
    RclTokens.WHEN_KW,
    RclTokens.UNLESS_KW,
    RclTokens.THEN_KW,
    RclTokens.ELSE_KW,
    RclTokens.AND_KW,
    RclTokens.OR_KW,
    RclTokens.NOT_KW,
    RclTokens.IF_KW,
    RclTokens.IS_KW,
    RclTokens.DO_KW,
    RclTokens.END_KW,

    // Collection keywords
    RclTokens.LIST_KW,
    RclTokens.OF_KW,

    // Message traffic type keywords
    RclTokens.TRANSACTIONAL_KW,
    RclTokens.PROMOTIONAL_KW,

    // Boolean keywords (longer patterns first)
    RclTokens.ENABLED_KW,
    RclTokens.DISABLED_KW,
    RclTokens.INACTIVE_KW,
    RclTokens.ACTIVE_KW,
    RclTokens.TRUE_KW,
    RclTokens.FALSE_KW,
    RclTokens.YES_KW,
    RclTokens.NO_KW,
    RclTokens.ON_KW,
    RclTokens.OFF_KW,

    // Null keywords
    RclTokens.NULL_KW,
    RclTokens.NULL_LOWERCASE_KW,
    RclTokens.NONE_KW,
    RclTokens.VOID_KW,

    // Reserved names
    RclTokens.DEFAULTS_KW,
    RclTokens.CONFIG_KW,
    RclTokens.MESSAGES_RESERVED_KW,

    // Type tag names (longer patterns first)
    RclTokens.DATETIME_TYPE,
    RclTokens.ZIPCODE_TYPE,
    RclTokens.DURATION_TYPE,
    RclTokens.EMAIL_TYPE,
    RclTokens.PHONE_TYPE,
    RclTokens.MSISDN_TYPE,
    RclTokens.URL_TYPE,
    RclTokens.TIME_TYPE,
    RclTokens.DATE_TYPE,
    RclTokens.ZIP_TYPE,
    RclTokens.TTL_TYPE,
    RclTokens.DT_TYPE,
    RclTokens.T_TYPE,

    // Literals (specific before general)
    RclTokens.ISO_DURATION_LITERAL,
    RclTokens.STRING,
    RclTokens.NUMBER,
    RclTokens.ATOM,

    // Identifiers (after keywords and literals)
    RclTokens.IDENTIFIER,
    RclTokens.ATTRIBUTE_KEY,
    RclTokens.SECTION_TYPE,

    // Embedded expressions
    RclTokens.MULTI_LINE_EXPRESSION_START,
    RclTokens.EMBEDDED_CODE,

    // Multi-line string markers (specific before general PIPE)
    RclTokens.MULTILINE_STR_PRESERVE_ALL,
    RclTokens.MULTILINE_STR_PRESERVE,
    RclTokens.MULTILINE_STR_TRIM,
    RclTokens.MULTILINE_STR_CLEAN,
    
    // Content tokens
    RclTokens.STRING_CONTENT,
    RclTokens.MULTI_LINE_EXPRESSION_CONTENT,
    RclTokens.TYPE_TAG_VALUE_CONTENT,
    RclTokens.TYPE_TAG_MODIFIER_CONTENT,

    // Punctuation (longer patterns first)
    RclTokens.ARROW,
    RclTokens.APOSTROPHE_S,
    RclTokens.PIPE,
    RclTokens.COLON,
    RclTokens.COMMA,
    RclTokens.DOT,
    RclTokens.SLASH,
    RclTokens.HYPHEN,
    RclTokens.DOLLAR,
    RclTokens.PERCENT,
    RclTokens.AT,
    RclTokens.CARET,

    // Brackets and braces
    RclTokens.LPAREN,
    RclTokens.RPAREN,
    RclTokens.LBRACE,
    RclTokens.RBRACE,
    RclTokens.LBRACKET,
    RclTokens.RBRACKET,
    RclTokens.LT,
    RclTokens.GT,
  ];

  /**
   * Get all token types for external integration
   */
  static getAllTokens(): TokenType[] {
    return RclTokens.ALL_TOKENS;
  }

  /**
   * Get keyword tokens only
   */
  static getKeywordTokens(): TokenType[] {
    return [
      // Import keywords
      RclTokens.IMPORT_KW, RclTokens.AS_KW, RclTokens.FROM_KW,
      
      // Section keywords
      RclTokens.AGENT_KW, RclTokens.AGENT_DEFAULTS_KW, RclTokens.AGENT_CONFIG_KW,
      RclTokens.FLOW_KW, RclTokens.FLOWS_KW, RclTokens.MESSAGES_KW,
      
      // Message keywords
      RclTokens.AGENT_MESSAGE_KW, RclTokens.CONTENT_MESSAGE_KW, RclTokens.SUGGESTION_KW,
      
      // Shortcut keywords
      RclTokens.TEXT_KW, RclTokens.RICH_CARD_KW, RclTokens.CAROUSEL_KW,
      RclTokens.RBM_FILE_KW, RclTokens.FILE_KW,
      
      // Action keywords
      RclTokens.REPLY_KW, RclTokens.ACTION_KW, RclTokens.DIAL_KW,
      RclTokens.OPEN_URL_KW, RclTokens.SHARE_LOCATION_KW, RclTokens.VIEW_LOCATION_KW,
      RclTokens.SAVE_EVENT_KW,
      
      // Flow control keywords
      RclTokens.START_KW, RclTokens.WITH_KW, RclTokens.WHEN_KW,
      RclTokens.IF_KW, RclTokens.THEN_KW, RclTokens.ELSE_KW, RclTokens.UNLESS_KW,
      RclTokens.AND_KW, RclTokens.OR_KW, RclTokens.NOT_KW, RclTokens.IS_KW,
      RclTokens.DO_KW, RclTokens.END_KW,
      
      // Collection keywords
      RclTokens.LIST_KW, RclTokens.OF_KW,
      
      // Message type keywords
      RclTokens.TRANSACTIONAL_KW, RclTokens.PROMOTIONAL_KW
    ];
  }

  /**
   * Get type tag name tokens
   */
  static getTypeTagTokens(): TokenType[] {
    return [
      RclTokens.EMAIL_TYPE, RclTokens.PHONE_TYPE, RclTokens.MSISDN_TYPE,
      RclTokens.URL_TYPE, RclTokens.TIME_TYPE, RclTokens.T_TYPE,
      RclTokens.DATETIME_TYPE, RclTokens.DATE_TYPE, RclTokens.DT_TYPE,
      RclTokens.ZIPCODE_TYPE, RclTokens.ZIP_TYPE, RclTokens.DURATION_TYPE,
      RclTokens.TTL_TYPE
    ];
  }
}