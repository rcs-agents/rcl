/**
 * Grammar Comparison Tests
 * 
 * Tests that compare grammars generated by tmgrammar-toolkit with those 
 * generated by the original tmlanguage-generator package.
 */

import { describe, test, expect, beforeAll, it } from 'vitest';
import { createGrammar } from '../src/index.js';
import { readFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

import { grammar as bicepGrammar } from '../examples/tmgrammar-toolkit/bicep.ts';
import { grammar as typespecGrammar } from '../examples/tmgrammar-toolkit/typespec.ts';
import { grammar as jsonGrammar } from './fixtures/grammars/json-simple.js';
import { grammar as simpleLangGrammar } from './fixtures/grammars/simple-lang.js';
import { grammar as markdownGrammar } from './fixtures/grammars/markdown-basic.js';
import { emitJSON } from '../src/emit.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

describe('Grammar Comparison Tests', () => {
  const fixturesPath = resolve(__dirname, 'fixtures/emit');
  
  let originalBicepGrammar: any;
  let originalTypespecGrammar: any;
  let textmateToolkitBicepGrammar: any;
  let textmateToolkitTypespecGrammar: any;

  beforeAll(async () => {
    // Load original tmlanguage JSON files
    const bicepJsonPath = resolve(fixturesPath, 'bicep.tmlanguage.json');
    const typespecJsonPath = resolve(fixturesPath, 'typescpec.tmlanguage.json'); // Note: original has typo
    
    const bicepJson = await readFile(bicepJsonPath, 'utf-8');
    const typespecJson = await readFile(typespecJsonPath, 'utf-8');
    
    originalBicepGrammar = JSON.parse(bicepJson);
    originalTypespecGrammar = JSON.parse(typespecJson);
    
    // Generate tmgrammar-toolkit outputs using emitJSON
    const bicepGrammarJson = await emitJSON(bicepGrammar);
    const typespecGrammarJson = await emitJSON(typespecGrammar);
    
    textmateToolkitBicepGrammar = JSON.parse(bicepGrammarJson);
    textmateToolkitTypespecGrammar = JSON.parse(typespecGrammarJson);
  });

  describe('Bicep Grammar Comparison', () => {
    it('should match the snapshot', () => {
      expect(textmateToolkitBicepGrammar).toMatchSnapshot();
    });
  });

  describe('TypeSpec Grammar Comparison', () => {
    it('should match the snapshot', () => {
      expect(textmateToolkitTypespecGrammar).toMatchSnapshot();
    });
  });

  describe('Additional Grammar Tests', () => {
    it('should generate valid JSON grammar', async () => {
      const jsonGrammarJson = await emitJSON(jsonGrammar);
      const parsed = JSON.parse(jsonGrammarJson);
      
      expect(parsed.name).toBe('JSON Simple');
      expect(parsed.scopeName).toBe('source.json-simple');
      expect(parsed.fileTypes).toEqual(['json']);
      expect(parsed.patterns).toHaveLength(1);
      expect(parsed.patterns[0].include).toBe('#value');
      expect(Object.keys(parsed.repository)).toHaveLength(7);
      
      // Test specific patterns
      expect(parsed.repository.number.match).toBe('-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?');
      expect(parsed.repository.boolean.match).toBe('\\b(true|false)\\b');
      expect(parsed.repository.array.begin).toBe('\\[');
      expect(parsed.repository.array.end).toBe('\\]');
      
      expect(jsonGrammarJson).toMatchSnapshot();
    });

    it('should generate valid simple language grammar', async () => {
      const simpleLangJson = await emitJSON(simpleLangGrammar);
      const parsed = JSON.parse(simpleLangJson);
      
      expect(parsed.name).toBe('Simple Language');
      expect(parsed.scopeName).toBe('source.simple-lang');
      expect(parsed.fileTypes).toEqual(['simple', 'sl']);
      expect(parsed.patterns).toHaveLength(9);
      expect(Object.keys(parsed.repository)).toHaveLength(9);
      
      // Test keyword pattern
      expect(parsed.repository.keywords.match).toBe('\\b(if|else|while|for|function|return|var|let|const)\\b');
      expect(parsed.repository.keywords.name).toBe('keyword.control');
      
      // Test function pattern
      expect(parsed.repository['function-definition'].begin).toBe('(function)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(\\()');
      expect(parsed.repository['function-definition'].beginCaptures).toBeDefined();
      
      expect(simpleLangJson).toMatchSnapshot();
    });

    it('should generate valid markdown grammar', async () => {
      const markdownJson = await emitJSON(markdownGrammar);
      const parsed = JSON.parse(markdownJson);
      
      expect(parsed.name).toBe('Markdown Basic');
      expect(parsed.scopeName).toBe('text.html.markdown.basic');
      expect(parsed.fileTypes).toEqual(['md', 'markdown']);
      expect(parsed.patterns).toHaveLength(8);
      expect(Object.keys(parsed.repository)).toHaveLength(8);
      
      // Test heading pattern
      expect(parsed.repository.heading.match).toBe('^(#{1,6})\\s+(.+)$');
      expect(parsed.repository.heading.captures).toBeDefined();
      
      // Test link pattern
      expect(parsed.repository.link.match).toBe('\\[([^\\]]+)\\]\\(([^)]+)\\)');
      expect(parsed.repository.link.captures).toBeDefined();
      
      expect(markdownJson).toMatchSnapshot();
    });
  });
}); 