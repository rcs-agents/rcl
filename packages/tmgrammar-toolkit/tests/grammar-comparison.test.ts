/**
 * Grammar Comparison Tests
 * 
 * Tests that compare grammars generated by tmgrammar-toolkit with those 
 * generated by the original tmlanguage-generator package.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { readFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { grammar as bicepGrammar } from './fixtures/grammar-comparison/bicep.ts';
import { grammar as typespecGrammar } from './fixtures/grammar-comparison/typespec.ts';
import { emitJSON } from '../src/emit.js';

describe('Grammar Comparison Tests', () => {
  const fixturesPath = resolve(__dirname, 'fixtures/grammar-comparison');
  
  let originalBicepGrammar: any;
  let originalTypespecGrammar: any;
  let textmateToolkitBicepGrammar: any;
  let textmateToolkitTypespecGrammar: any;

  beforeAll(async () => {
    // Load original tmlanguage JSON files
    const bicepJsonPath = resolve(fixturesPath, 'bicep.tmlanguage.json');
    const typespecJsonPath = resolve(fixturesPath, 'typescpec.tmlanguage.json'); // Note: original has typo
    
    const bicepJson = await readFile(bicepJsonPath, 'utf-8');
    const typespecJson = await readFile(typespecJsonPath, 'utf-8');
    
    originalBicepGrammar = JSON.parse(bicepJson);
    originalTypespecGrammar = JSON.parse(typespecJson);
    
    // Generate tmgrammar-toolkit outputs using emitJSON
    const bicepGrammarJson = await emitJSON(bicepGrammar);
    const typespecGrammarJson = await emitJSON(typespecGrammar);
    
    textmateToolkitBicepGrammar = JSON.parse(bicepGrammarJson);
    textmateToolkitTypespecGrammar = JSON.parse(typespecGrammarJson);
  });

  describe('Bicep Grammar Comparison', () => {
    it('should have matching schema', () => {
      expect(textmateToolkitBicepGrammar.$schema).toBe(originalBicepGrammar.$schema);
    });

    it('should have matching name', () => {
      expect(textmateToolkitBicepGrammar.name).toBe(originalBicepGrammar.name);
    });

    it('should have matching scopeName', () => {
      expect(textmateToolkitBicepGrammar.scopeName).toBe(originalBicepGrammar.scopeName);
    });

    it('should have matching fileTypes', () => {
      expect(textmateToolkitBicepGrammar.fileTypes).toEqual(originalBicepGrammar.fileTypes);
    });

    it('should have a repository with rules', () => {
      expect(textmateToolkitBicepGrammar.repository).toBeDefined();
      expect(typeof textmateToolkitBicepGrammar.repository).toBe('object');
      expect(Object.keys(textmateToolkitBicepGrammar.repository).length).toBeGreaterThan(0);
    });

    it('should have patterns that reference repository rules', () => {
      expect(textmateToolkitBicepGrammar.patterns).toBeDefined();
      expect(Array.isArray(textmateToolkitBicepGrammar.patterns)).toBe(true);
      expect(textmateToolkitBicepGrammar.patterns.length).toBeGreaterThan(0);
    });

    it('should generate valid TextMate grammar structure', () => {
      // Check basic structure
      expect(textmateToolkitBicepGrammar).toHaveProperty('$schema');
      expect(textmateToolkitBicepGrammar).toHaveProperty('name');
      expect(textmateToolkitBicepGrammar).toHaveProperty('scopeName');
      expect(textmateToolkitBicepGrammar).toHaveProperty('fileTypes');
      expect(textmateToolkitBicepGrammar).toHaveProperty('patterns');
      expect(textmateToolkitBicepGrammar).toHaveProperty('repository');
    });

    it('should have repository rules with correct structure', () => {
      const repository = textmateToolkitBicepGrammar.repository;
      
      // Check that each rule has proper structure
      for (const [key, rule] of Object.entries(repository)) {
        expect(typeof key).toBe('string');
        expect(rule).toBeDefined();
        
        // Each rule should have either match, begin/end, or patterns
        const hasMatch = 'match' in (rule as object);
        const hasBeginEnd = 'begin' in (rule as object) && 'end' in (rule as object);
        const hasPatterns = 'patterns' in (rule as object);
        
        expect(hasMatch || hasBeginEnd || hasPatterns).toBe(true);
      }
    });

    it('should have similar repository structure to original', () => {
      const originalKeys = Object.keys(originalBicepGrammar.repository).sort();
      const toolkitKeys = Object.keys(textmateToolkitBicepGrammar.repository).sort();
      
      // We should have at least the same number of rules as the original
      expect(toolkitKeys.length).toBeGreaterThanOrEqual(originalKeys.length * 0.8); // Allow some variance
    });
  });

  describe('TypeSpec Grammar Comparison', () => {
    it('should have matching schema', () => {
      expect(textmateToolkitTypespecGrammar.$schema).toBe(originalTypespecGrammar.$schema);
    });

    it('should have matching name', () => {
      expect(textmateToolkitTypespecGrammar.name).toBe(originalTypespecGrammar.name);
    });

    it('should have matching scopeName', () => {
      expect(textmateToolkitTypespecGrammar.scopeName).toBe(originalTypespecGrammar.scopeName);
    });

    it('should have matching fileTypes', () => {
      expect(textmateToolkitTypespecGrammar.fileTypes).toEqual(originalTypespecGrammar.fileTypes);  
    });

    it('should have a repository with rules', () => {
      expect(textmateToolkitTypespecGrammar.repository).toBeDefined();
      expect(typeof textmateToolkitTypespecGrammar.repository).toBe('object');
      expect(Object.keys(textmateToolkitTypespecGrammar.repository).length).toBeGreaterThan(0);
    });

    it('should have patterns that reference repository rules', () => {
      expect(textmateToolkitTypespecGrammar.patterns).toBeDefined();
      expect(Array.isArray(textmateToolkitTypespecGrammar.patterns)).toBe(true);
      expect(textmateToolkitTypespecGrammar.patterns.length).toBeGreaterThan(0);
    });

    it('should generate valid TextMate grammar structure', () => {
      // Check basic structure
      expect(textmateToolkitTypespecGrammar).toHaveProperty('$schema');
      expect(textmateToolkitTypespecGrammar).toHaveProperty('name');
      expect(textmateToolkitTypespecGrammar).toHaveProperty('scopeName');
      expect(textmateToolkitTypespecGrammar).toHaveProperty('fileTypes');
      expect(textmateToolkitTypespecGrammar).toHaveProperty('patterns');
      expect(textmateToolkitTypespecGrammar).toHaveProperty('repository');
    });

    it('should have repository rules with correct structure', () => {
      const repository = textmateToolkitTypespecGrammar.repository;
      
      // Check that each rule has proper structure
      for (const [key, rule] of Object.entries(repository)) {
        expect(typeof key).toBe('string');
        expect(rule).toBeDefined();
        
        // Each rule should have either match, begin/end, or patterns
        const hasMatch = 'match' in (rule as object);
        const hasBeginEnd = 'begin' in (rule as object) && 'end' in (rule as object);
        const hasPatterns = 'patterns' in (rule as object);
        
        expect(hasMatch || hasBeginEnd || hasPatterns).toBe(true);
      }
    });

    it('should have similar repository structure to original', () => {
      const originalKeys = Object.keys(originalTypespecGrammar.repository).sort();
      const toolkitKeys = Object.keys(textmateToolkitTypespecGrammar.repository).sort();
      
      // We should have at least some of the same rules as the original
      expect(toolkitKeys.length).toBeGreaterThanOrEqual(originalKeys.length * 0.3); // TypeSpec conversion is partial
    });
  });

  describe('Cross-Grammar Structure Validation', () => {
    it('should generate grammars with consistent structure', () => {
      const bicepKeys = Object.keys(textmateToolkitBicepGrammar).sort();
      const typespecKeys = Object.keys(textmateToolkitTypespecGrammar).sort();
      
      // Both should have the same top-level structure
      expect(bicepKeys).toEqual(typespecKeys);
    });

    it('should have non-empty repositories', () => {
      expect(Object.keys(textmateToolkitBicepGrammar.repository).length).toBeGreaterThan(0);
      expect(Object.keys(textmateToolkitTypespecGrammar.repository).length).toBeGreaterThan(0);
    });

    it('should have all repository rules accessible', () => {
      const bicepRepo = textmateToolkitBicepGrammar.repository;
      const typespecRepo = textmateToolkitTypespecGrammar.repository;
      
      // Each grammar should have at least some rules in repository
      expect(Object.keys(bicepRepo).length).toBeGreaterThan(5);
      expect(Object.keys(typespecRepo).length).toBeGreaterThan(5);
    });
  });

  describe('JSON Output Comparison', () => {
    it('should generate valid JSON that matches original structure', async () => {
      // Test that our generated JSON is parseable and structurally similar
      const bicepJson = await emitJSON(bicepGrammar);
      const typespecJson = await emitJSON(typespecGrammar);
      
      expect(() => JSON.parse(bicepJson)).not.toThrow();
      expect(() => JSON.parse(typespecJson)).not.toThrow();
      
      const parsedBicep = JSON.parse(bicepJson);
      const parsedTypespec = JSON.parse(typespecJson);
      
      // Check that the parsed JSON has all required fields
      expect(parsedBicep).toHaveProperty('$schema');
      expect(parsedBicep).toHaveProperty('name');
      expect(parsedBicep).toHaveProperty('scopeName');
      expect(parsedBicep).toHaveProperty('fileTypes');
      expect(parsedBicep).toHaveProperty('patterns');
      expect(parsedBicep).toHaveProperty('repository');
      
      expect(parsedTypespec).toHaveProperty('$schema');
      expect(parsedTypespec).toHaveProperty('name');
      expect(parsedTypespec).toHaveProperty('scopeName');
      expect(parsedTypespec).toHaveProperty('fileTypes');
      expect(parsedTypespec).toHaveProperty('patterns');
      expect(parsedTypespec).toHaveProperty('repository');
    });
  });

  describe('Regression Tests', () => {
    it('should maintain consistent grammar structure over time', () => {
      // Save current structure for regression testing
      const bicepStructure = {
        schema: textmateToolkitBicepGrammar.$schema,
        name: textmateToolkitBicepGrammar.name,
        scopeName: textmateToolkitBicepGrammar.scopeName,
        fileTypes: textmateToolkitBicepGrammar.fileTypes,
        repositoryKeys: Object.keys(textmateToolkitBicepGrammar.repository).sort(),
        patternsLength: textmateToolkitBicepGrammar.patterns.length
      };

      const typespecStructure = {
        schema: textmateToolkitTypespecGrammar.$schema,
        name: textmateToolkitTypespecGrammar.name,
        scopeName: textmateToolkitTypespecGrammar.scopeName,
        fileTypes: textmateToolkitTypespecGrammar.fileTypes,
        repositoryKeys: Object.keys(textmateToolkitTypespecGrammar.repository).sort(),
        patternsLength: textmateToolkitTypespecGrammar.patterns.length
      };

      // These snapshots will catch unintentional changes
      expect(bicepStructure).toMatchSnapshot('bicep-grammar-structure');
      expect(typespecStructure).toMatchSnapshot('typespec-grammar-structure');
    });
  });
}); 